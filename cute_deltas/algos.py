# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_algos.ipynb (unless otherwise specified).

__all__ = ['levenshtein_distance', 'n_gram_overlap']

# Cell

# This code was taken from https://gist.github.com/kylebgorman/1081951/bce3de986e4b05fc0b63d4d9e0cfa4bde6664365
def _dist(A, B, insertion, deletion, substitution):
    D = np.zeros((len(A) + 1, len(B) + 1))
    for i in range(len(A)):
        D[i + 1][0] = D[i][0] + deletion
    for j in range(len(B)):
        D[0][j + 1] = D[0][j] + insertion
    for i in range(len(A)): # fill out middle of matrix
        for j in range(len(B)):
            if A[i] == B[j]:
                D[i + 1][j + 1] = D[i][j] # aka, it's free.
            else:
                D[i + 1][j + 1] = min(D[i + 1][j] + insertion,
                                      D[i][j + 1] + deletion,
                                      D[i][j]     + substitution)
    return D

def levenshtein_distance(l1, l2, normalize=False):
    dist = _dist(l1, l2, 1, 1, 1)[-1][-1]
    if normalize:
        return 1. - dist / max(len(l1), len(l2))
    else:
        return dist

# Cell
# implementation inspired from https://yunjinhan.github.io/2017/04/n-gram-overlap

def _n_grams(l, n):
    grams = []
    for i in range(0, len(l) + 1 - n):
        grams.append(l[i:i + n])

    return grams

def n_gram_overlap(l1, l2, n, normalize=False):
    l1_grams = _n_grams(l1, n)
    l2_grams = _n_grams(l2, n)

    overlap = len(set(l1_grams) & set(l2_grams))
    if normalize:
        return overlap / max(len(l1_grams), len(l2_grams))
    else:
        return overlap